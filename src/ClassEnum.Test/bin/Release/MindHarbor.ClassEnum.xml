<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MindHarbor.ClassEnum</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:MindHarbor.ClassEnum.ClassEnumGeneric`1" -->
        <member name="T:MindHarbor.ClassEnum.ClassEnumBase">
            <summary>
            The base class for Class Enumeration
            </summary>
            <remarks>
            Do not inherit from this class, inherit from <see cref="!:ClassEnumGeneric"/>.
            Types can be automatically initialized 
            or you can use a AppSetting with the name "MindHarbor.ClassEnum.ClassEnumTypes" to define which ClassEnum types to be included.
            
            </remarks>
        </member>
        <member name="T:MindHarbor.ClassEnum.IClassEnum">
            <summary>
            The type safe Enumeration pattern 
            </summary>
        </member>
        <member name="P:MindHarbor.ClassEnum.IClassEnum.Name">
            <summary>
            string reprentation of the enum item
            </summary>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumBase.Parse(System.Type,System.String)">
            <summary>
            Parse the name to the T type of enumeration
            </summary>
            <param name="t"></param>
            <param name="enumName"></param>
            <returns></returns>
            <remarks>
            This method is only for ClassEnumUserType to use
            </remarks>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumBase.ClassEnumRepo.InitializeType(System.Type)">
            <summary>
            To initialize the ClassEnum type
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumGeneric`1.Parse(System.String)">
            <summary>
            Parse the enum by name
            </summary>
            <param name="enumName"></param>
            <returns></returns>
        </member>
        <member name="P:MindHarbor.ClassEnum.ClassEnumGeneric`1.Items">
            <summary>
            Gets the collection of all the items
            </summary>
        </member>
        <member name="T:MindHarbor.ClassEnum.ClassEnumUserType`1">
            <summary>
            Base class for ClassEnum UserType
            </summary>
            <typeparam name="EnumT"></typeparam>
        </member>
        <member name="F:MindHarbor.ClassEnum.ClassEnumUserType`1.CustomeType">
            <summary>
            The customer Type needed when in Nhibernate.Query.SetParameter()
            </summary>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumUserType`1.Equals(System.Object,System.Object)">
            <summary>
            
                        Compare two instances of the class mapped by this type for persistent "equality"
                        ie. equality of persistent state
                        
            </summary>
            
            <param name="x"></param>
            <param name="y"></param>
            <returns>
            
            </returns>
            
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumUserType`1.GetHashCode(System.Object)">
            <summary>
            Get a hashcode for the instance, consistent with persistence "equality" 
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumUserType`1.NullSafeGet(System.Data.IDataReader,System.String[],System.Object)">
            <summary>
            
                        Retrieve an instance of the mapped class from a JDBC resultset.
                        Implementors should handle possibility of null values.
                        
            </summary>
            
            <param name="rs">a IDataReader</param>
            <param name="names">column names</param>
            <param name="owner">the containing entity</param>
            <returns>
            
            </returns>
            
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumUserType`1.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
                        Write an instance of the mapped class to a prepared statement.
                        Implementors should handle possibility of null values.
                        A multi-column type should be written to parameters starting from index.
                        
            </summary>
            
            <param name="cmd">a IDbCommand</param>
            <param name="value">the object to write</param>
            <param name="index">command parameter index</param>
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MindHarbor.ClassEnum.ClassEnumUserType`1.DeepCopy(System.Object)" -->
        <member name="M:MindHarbor.ClassEnum.ClassEnumUserType`1.Replace(System.Object,System.Object,System.Object)">
            <summary>
            
                        During merge, replace the existing (<paramref name="target" />) value in the entity
                        we are merging to with a new (<paramref name="original" />) value from the detached
                        entity we are merging. For immutable objects, or null values, it is safe to simply
                        return the first parameter. For mutable objects, it is safe to return a copy of the
                        first parameter. For objects with component values, it might make sense to
                        recursively replace component values.
                        
            </summary>
            
            <param name="original">the value from the detached entity being merged</param>
            <param name="target">the value in the managed entity</param>
            <param name="owner">the managed entity</param>
            <returns>
            the value to be merged
            </returns>
            
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumUserType`1.Assemble(System.Object,System.Object)">
            <summary>
            
                        Reconstruct an object from the cacheable representation. At the very least this
                        method should perform a deep copy if the type is mutable. (optional operation)
                        
            </summary>
            
            <param name="cached">the object to be cached</param>
            <param name="owner">the owner of the cached object</param>
            <returns>
            a reconstructed object from the cachable representation
            </returns>
            
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumUserType`1.Disassemble(System.Object)">
            <summary>
            
                        Transform the object into its cacheable representation. At the very least this
                        method should perform a deep copy if the type is mutable. That may not be enough
                        for some implementations, however; for example, associations must be cached as
                        identifier values. (optional operation)
                        
            </summary>
            
            <param name="value">the object to be cached</param>
            <returns>
            a cacheable representation of the object
            </returns>
            
        </member>
        <member name="P:MindHarbor.ClassEnum.ClassEnumUserType`1.SqlTypes">
            <summary>
            
                        The SQL types for the columns mapped by this type. 
                        
            </summary>
            
        </member>
        <member name="P:MindHarbor.ClassEnum.ClassEnumUserType`1.ReturnedType">
            <summary>
            
                        The type returned by 
            <c>NullSafeGet()</c>
            </summary>
            
        </member>
        <member name="P:MindHarbor.ClassEnum.ClassEnumUserType`1.IsMutable">
            <summary>
            
                        Are objects of this type mutable?
                        
            </summary>
            
        </member>
        <member name="T:MindHarbor.ClassEnum.ClassEnumException">
            <summary>
            ClassEnum related exception
            </summary>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:MindHarbor.ClassEnum.ClassEnumException.#ctor">
            <summary>
            
            </summary>
        </member>
    </members>
</doc>
