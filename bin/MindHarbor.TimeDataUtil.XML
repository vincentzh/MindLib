<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MindHarbor.TimeDataUtil</name>
    </assembly>
    <members>
        <member name="T:MindHarbor.TimeDataUtil.DateRange">
            <summary>
            A timeRange of days
            </summary>
            <remarks>
            the basic unit of this DateRange is day. 
            </remarks>
        </member>
        <member name="T:MindHarbor.TimeDataUtil.DateTimeRange">
            <summary>
            A data structure class that represents a range of time
            </summary>
            <remarks>
            This is an immutable class. It's inheritance should also be.
            </remarks>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.#ctor(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.Equals(System.Object)">
            <summary>overriden
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.Equals(System.Object,System.Object)">
            <summary>
             overriden
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.GetHashCode">
            <summary>overriden
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.ToString">
            <summary>overriden
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.ToString(System.String)">
            <summary>
            overriden
            </summary>
            <param name="fString"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.Includes(System.DateTime)">
            <summary>
            Whether the time is within this range
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.LaterEqualThanStart(System.Nullable{System.DateTime})">
            <summary>
            Tell whether the time is later than the start of this range
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.EarlierEqualThanEnd(System.Nullable{System.DateTime})">
            <summary>
            tell whether the time is earlier than the end of this range
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.RangeExpression(System.String)">
            <summary>
            Create a expression of a Datetime property within this DateTimeRange
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.WithinExpression(System.String)">
            <summary>
            Create a NHibernate criterion expression of a DateTimeRange property within this DateTimeRange
            </summary> 
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRange.LargerOrEqual(MindHarbor.TimeDataUtil.DateRange)">
            <summary>
            Whether this range is lager or equal than <paramref name="dr"/>
            </summary>
            <param name="dr"></param>
            <returns></returns>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRange.DefaultFormatString">
            <summary>
            The default format string when ToString()
            </summary>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRange.End">
            <summary>
            </summary>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRange.Start">
            <summary>
            </summary>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRange.Center">
            <summary>
            Gets the center point of the Time Range
            </summary>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRange.IsOpen">
            <summary>
            Gets if the range is open
            </summary>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.#ctor(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
            <summary>
            
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.#ctor(System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
            <summary>
            Note that the end date will actually be the start second of the next date
            so there is always an at least 24 hours TimeSpan for a DateTimeRange.
            </summary>
            <param name="end">the last day that should be included in the range</param>
            <param name="start">the first day that should be inlcuded in the range</param>
            <param name="includeDays"> whether to include the whole day time of the start and end date</param>
            <remarks>The last millisecond of the last day is out of the DateRange</remarks>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.Parse(System.String)">
            <summary>
            Parse the <see cref="T:MindHarbor.TimeDataUtil.DateRange"/> from a string representation <paramref name="val"/>
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.AddYears(System.Int32)">
            <summary>
            Note that if you are using a special date range, this method will just add/remove years
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.Quarter(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="year"></param>
            <param name="numOfQuarter">1, 2, 3,4</param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.QuarterOf(System.Int32,System.Int32)">
            <summary>
            Gets the quarter in which the day locates 
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.QuarterOf(System.DateTime)">
            <summary>
            Gets the quarter in which the <paramref name="dt"/> locates 
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.MonthOf(System.DateTime)">
            <summary>
            return the date range of the month the day belongs to
            </summary>
            <param name="day"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.Month(System.Int32,System.Int32)">
            <summary>
            return the date range reprensents the month
            </summary>
            <param name="year"></param>
            <param name="month"></param>
            <returns></returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateRange.Year(System.Int32)">
            <summary>
            return the date range reprensents the whole year
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateRange.DefaultFormatString">
            <summary>
            The default format string when ToString()
            </summary>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateRange.ThisMonth">
            <summary>
            </summary>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateRange.LastMonth">
            <summary>
            </summary>
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateRange.NextMonth">
            <summary>
            </summary>
        </member>
        <member name="T:MindHarbor.TimeDataUtil.DateRangeUserType">
            <summary>
             A NHibernate user type for this class
            </summary>
        </member>
        <member name="T:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1">
            <summary>
            A base class for <see cref="T:MindHarbor.TimeDataUtil.DateTimeRange"/>  NHibernate UserTypes
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.NullRangeEnd">
            <summary>
            Meaningless datetime for storing null daterange into the database. <seealso cref="F:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.NullRangeStart"/>
            </summary>
        </member>
        <member name="F:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.NullRangeStart">
            <summary>
            Meaningless <see cref="T:System.DateTime"/> for storing null <see cref="T:MindHarbor.TimeDataUtil.DateTimeRange"/> into the database
            </summary>
            <remarks>
            The NullRangeStart is larger than the NullRangeEnd, so this DateTime pair will never appear in the real scenario.
            DO NOT CHANGE THESE VALUES EVER.
            </remarks>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.GetPropertyValue(System.Object,System.Int32)">
            <summary>
               Get the value of a property
            </summary>
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <returns>
            the property value
            </returns>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            
                        Set the value of a property
                        
            </summary>
            
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <param name="value">the value to set</param>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.Equals(System.Object,System.Object)">
            <summary>
            
                        Compare two instances of the class mapped by this type for persistence
                        "equality", ie. equality of persistent state.
                        
            </summary>
            
            <param name="x"></param>
            <param name="y"></param>
            <returns>
            
            </returns>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.GetHashCode(System.Object)">
            <summary>
            
                        Get a hashcode for the instance, consistent with persistence "equality"
                        
            </summary>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
                        Retrieve an instance of the mapped class from a IDataReader. Implementors
                        should handle possibility of null values.
                        
            </summary>
            
            <param name="dr">IDataReader</param>
            <param name="names">the column names</param>
            <param name="session"></param>
            <param name="owner">the containing entity</param>
            <returns>
            
            </returns>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
                        Write an instance of the mapped class to a prepared statement.
                        Implementors should handle possibility of null values.
                        A multi-column type should be written to parameters starting from index.
                        
            </summary>
            
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.DeepCopy(System.Object)">
            <summary>
            
                        Return a deep copy of the persistent state, stopping at entities and at collections.
                        
            </summary>
            
            <param name="value">generally a collection element or entity field</param>
            <returns>
            
            </returns>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
                        Transform the object into its cacheable representation.
                        At the very least this method should perform a deep copy.
                        That may not be enough for some implementations, method should perform a deep copy. That may not be enough for some implementations, however; for example, associations must be cached as identifier values. (optional operation)
                        
            </summary>
            
            <param name="value">the object to be cached</param>
            <param name="session"></param>
            <returns>
            
            </returns>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
                        Reconstruct an object from the cacheable representation.
                        At the very least this method should perform a deep copy. (optional operation)
                        
            </summary>
            
            <param name="cached">the object to be cached</param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns>
            
            </returns>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.Replace(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
                        During merge, replace the existing (target) value in the entity we are merging to
                        with a new (original) value from the detached entity we are merging. For immutable
                        objects, or null values, it is safe to simply return the first parameter. For
                        mutable objects, it is safe to return a copy of the first parameter. However, since
                        composite user types often define component values, it might make sense to recursively 
                        replace component values in the target object.
                        
            </summary>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.Replace(System.Object,System.Object,System.Object)">
            <summary>
            
                        During merge, replace the existing (<paramref name="target" />) value in the entity
                        we are merging to with a new (<paramref name="original" />) value from the detached
                        entity we are merging. For immutable objects, or null values, it is safe to simply
                        return the first parameter. For mutable objects, it is safe to return a copy of the
                        first parameter. For objects with component values, it might make sense to
                        recursively replace component values.
                        
            </summary>
            
            <param name="original">the value from the detached entity being merged</param>
            <param name="target">the value in the managed entity</param>
            <param name="owner">the managed entity</param>
            <returns>
            the value to be merged
            </returns>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.Assemble(System.Object,System.Object)">
            <summary>
            
                        Reconstruct an object from the cacheable representation. At the very least this
                        method should perform a deep copy if the type is mutable. (optional operation)
                        
            </summary>
            
            <param name="cached">the object to be cached</param>
            <param name="owner">the owner of the cached object</param>
            <returns>
            a reconstructed object from the cachable representation
            </returns>
            
        </member>
        <member name="M:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.Disassemble(System.Object)">
            <summary>
            
                        Transform the object into its cacheable representation. At the very least this
                        method should perform a deep copy if the type is mutable. That may not be enough
                        for some implementations, however; for example, associations must be cached as
                        identifier values. (optional operation)
                        
            </summary>
            
            <param name="value">the object to be cached</param>
            <returns>
            a cacheable representation of the object
            </returns>
            
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.PropertyNames">
            <summary>
            
                        Get the "property names" that may be used in a query. 
                        
            </summary>
            
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.PropertyTypes">
            <summary>
            
                        Get the corresponding "property types"
                        
            </summary>
            
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.ReturnedClass">
            <summary>
            
                        The class returned by NullSafeGet().
                        
            </summary>
            
        </member>
        <member name="P:MindHarbor.TimeDataUtil.DateTimeRangeUserTypeGenericBase`1.IsMutable">
            <summary>
            
                        Are objects of this type mutable?
                        
            </summary>
            
        </member>
        <member name="T:MindHarbor.TimeDataUtil.DateTimeRangeUserType">
            <summary>
            NHiberante UserType for this class
            </summary>
        </member>
    </members>
</doc>
